- Definition 5: The sequential reachability should be defined formally. When we have reach(ls_1):: …::reach(ls_n) does it mean that the state ls_n is also reachable when ls_1 is reachable? 

- Proof of Theorem 3: Why "every local state in SLGC is mandatory to be reached"? Why perm (Ls)? The proof should be made more clear and also the assumptions under which the Theorem 3 holds.

- Section 4.3 should be made clearer. How the decision tree is constructed. How is it used to guide the search?

- Page 2, second column: The first and second sentences should be reformulated.
- Page 3, second column/line 50: "E" should be replaced by the set of edges of SCLG.
- Page 4, second column, line 50: "AN" —> "ABAN"
- Page 5, first column, line 50: "b_i" —> "b_j"
- Page 6, second column, line 34: The node a_1 is not a fork state.

- Definition 3: Since \omega is a local state, w\subseteq... should read w\in...
  According to the second equation, only members of the initial state \varsigma
  should be included, again that is in contradiction to all examples. Worse,
  the definition allows only one outgoing edge to one specific state for
  state nodes, this too is in contradiction with the examples. Moreover,
  V and V_a(sol_{a_i}}) are undefined, maybe they are the same, maybe not,
  but at any rate, we do not know which of the possible solutions for a_i
  the definition means.

- Theorem 1 is obviously wrong, Fig. 2 is a counterexample: There is a conflict
  on d, yet a_1 is reachable and should be considered as such by SLCG, as you
  point out earlier. Maybe "iff" in the theorem should read "if", but that
  would make it a much weaker statement.

- Algorithm 1 is wrong, it cannot even deal with completely linear trajectories.
  If my rules are A:=a0->b0, B:=b1->c0, and C:=c1->d0, the algorithm should
  come up with ABC but returns CBC. (bi is added to visited before the recursive
  call, preventing the recursion from going deeper than level two, and weirdly
  delta is prepended to the recursive result that already contains it.)

- Algorithm 1 does not tell us how it finds the right solution node from a
  given state node when there are several. (At least I suppose there can be
  several, as the examples show us.)