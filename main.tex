% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\RequirePackage{amsmath}
\documentclass[runningheads]{llncs}
%
\usepackage{amssymb}
\usepackage[noend]{algpseudocode} 
\usepackage{algorithm}

\usepackage{tikz}
\usepackage{graphicx}
\newcommand{\acm}[3]{\{#1\}\rightarrow#3}
\newcommand{\ac}[3]{$\{#1\}\rightarrow#3$}
\newcommand{\omesi}{^\omega_\varsigma}
\usepackage{url}
\input{macros}
\input{macros-ph}
\input{macros-abstr}
\input{tikzstyles2}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{A Heuristic for Reachability Problem in Asynchronous Binary Automata Networks\thanks{Supported by Laboratoire des Sciences du Num\'erique de Nantes and China Scholarship Council}}
%
\titlerunning{A Heuristic for Reachability Problem}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Xinwei Chai \and Morgan Magnin \and Olivier Roux}
%
\authorrunning{X. Chai et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Laboratoire des Sciences du Num\'erique de Nantes, UMR CNRS 6004 \'Ecole Centrale de Nantes, 1 rue de la No\"e - B.P. 92101 - 44321 Nantes Cedex 3, France \\
\email{\{xinwei.chai, morgan.magnin, olivier.roux\}@ls2n.fr}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
On the demand of efficient reachability analysis due to the inevitable complexity of large-scale biological models, this paper is dedicated to a novel approach: PermReach, for reachability problem of our new framework, Asynchronous Binary Automata Networks (ABAN). 
ABAN is an expressive modeling framework which contains all the dynamics behaviors performed by Asynchronous Boolean Networks. 
Compared to Boolean Networks (BN), ABAN has a finer description of state transitions (from a local state to another, instead of symmetric Boolean functions). 
To analyze the reachability properties on large-scale models (like the ones from systems biology), previous works have exhibited an efficient abstraction technique called Local Causality Graph (LCG).
However, this technique may be not conclusive. Our contribution here is to extend these results by tackling those complex intractable cases \textit{via} a heuristic technique. 
To validate our method, tests were conducted in large biological networks and randomly generated examples, showing that our method is more conclusive and faster than existing ones.

\keywords{Asynchronous Binary Automata Networks \and Simplified Local Causality Graph \and Heuristics.}
\end{abstract}
\section{Introduction}
\label{intro}
Works on concurrent systems have been of interest for systems biology for a decade \cite{bockmayr2002using,bortolussi2008modeling,wiley2003computational}. 
In this context, the challenges nowadays consist of not only model validation with regard to existing knowledge on systems but also behavior prediction of these systems. 
%In this context, reachability issue on formal models is a critical challenge which not only validates models with regard to existing knowledge on systems, but also addresses predictions of the behavior of these systems.
With quantities of available data provided by new technologies, \textit{e.g.} DNA microarray \cite{marx2013}, there is a growing need for high-performance analytic tools, especially for reachability problem, as many static and dynamical properties are transformable to the reachability of certain states.
Reachability problem has been studied under many different modeling frameworks for decades \cite{akutsu2007control,barrett2006complexity,Daws1998,esparza1998,mayr1984,wozna2003} and takes an important part in Model Checking \cite{clarke20142}. 
State Space Explosion problem arises in reachability analysis of concurrent systems as the state space is exponential to the number of components in the model, thus disables naive approaches. 

Related studies have been carried over various frameworks: Plateau et al. \cite{plateau1991stochastic} propose a Stochastic Automata Network and study its steady-state behavior, while the reachability analysis is absent; Li et al. \cite{li2012reachability,li2014stability} investigate theoretically the stability, controllability and reachability of Switched Boolean Networks, but their method remains computationally expensive.  
To tackle the State Space Explosion problem, symbolic model checking \cite{burch1992symbolic} and SAT-solvers \cite{abdulla2000symbolic} have been considered over years, but the solution space of original problem remains huge.
Paulev\'e \textit{et al.} \cite{folschette2015,pauleve2011} have proposed Automata Network (AN) for modeling concurrent systems. 
They provide an approach to address this issue by designing a static abstraction (with an over-approximation and an under-approximation of the real dynamics) inspired by abstract interpretation: Local Causality Graph (LCG). 
This static analysis drastically reduces the state-space and avoids costly global search \cite{pauleve2012}.

With the initiative of LCG, this paper is devoted to the study of general reachability problems in Asynchronous Binary Automata Networks (ABAN), then to gain a more profound understanding of the dynamics of biological systems. 
Many biological networks are encoded in Boolean style \cite{kauffman1969}, because BN is a simple formalism but with strong expressiveness also due to the imprecision of raw data.
However BN may be not expressive enough.
To model the dynamic behavior ``$a\gets$ $1$ when $b=1$'', one has $a(t+1)=b(t)$ in BN.
$a$ always follows the evolution of $b$ but with an unwanted behavior ``$a\gets 0$ when $b=0$''.
ABAN models this dynamics as \textit{via} \ac{b_1}{a_0}{a_1} without redundancy. 
Besides, BNs are transformable to Automata Networks, and this property makes ABAN more extendable (Appendix \ref{appendix:C}).

In many circumstances, LCG is able to give a conclusive result on the reachability of target states in polynomial time to the number of automata \cite{pauleve2016goal}. 
However there exists inconclusive cases which disable the reasoning of sufficient conditions.
After diving into the mechanics of LCG and the inconclusive cases, we figure out why those cases are intractable by pure static analysis. 
We develop a heuristic technique aiming at the application for general instances. 
This heuristic method has a better performance on conclusiveness than static reasoning, because it attempts to explore a part of the system dynamics \textit{via} partial verification.
In the end, we conduct tests on signaling networks of around 100 components (TCR and EGFR, see Section \ref{sect:5}): the results of LCG contain inconclusive instances \cite{folschette2015} while our new method solves them.

This paper is organized as follows: in section 2, we will introduce the formal background, Asynchronous Binary Automata Network (ABAN); section 3 presents the analysis of dynamics using only static reasoning; 
section 4 is the core content of this paper, concerning the solution of inconclusive cases; discussion about tests and conclusion are placed in section 5 and 6. \textcolor{red}{To revise at last}

\section{Preliminaries}\label{sect:2}
\textit{Notations}:
\textcolor{red}{verify if they are all used or add some new}
$::$ sequential connector;
$\#$ cardinal;
$a.$next the successor of $a$. 

Asynchronous Binary Automata Network (ABAN) is a variant of traditional AN.
Binary means that every automaton has exactly two possible states $(0,1)$ and asynchronous implies the update scheme with no more than one automaton can change its value at a time. 

\begin{definition}[ABAN]
An ABAN is a triplet $AB = (\mathbf{\Sigma},\mathbf{L},\mathbf{T})$, where:
\begin{itemize}
\item $\mathbf{\Sigma}\triangleq\{a,b,\ldots\}$ is the finite set of automata with every component possessing a Boolean state;
\item $L_a\triangleq\{a_0,a_1\}$ is the set of Boolean states of automaton $a\in \mathbf{\Sigma}$, $\mathbf{LS}\triangleq \underset{a\in \mathbf{\Sigma}}{\cup} L_a$ is the set of all local states,  $\mathbf{L}\triangleq \underset{a\in \mathbf{\Sigma'}}{\times} L_a$ is the set of joint states where $\mathbf{\Sigma'}\subseteq\mathbf{\Sigma}$. Particularly, if $\mathbf{\Sigma'}=\mathbf{\Sigma}$, $\mathbf{L}$ is the set of global states. 
The state of automaton $a$ at state $s$ is denoted $s[a]=a_i$;
\item $\mathbf{T}\subseteq \{A\to b_{i}\mid b\in \mathbf{\Sigma} \land A\in \mathbf{L}\}$ is the set of transitions, where $A$ is the set of required states for the transition, which allows to flip $b_{1-i}$ to $b_i$. $A$ is called head and $b_i$ is called body.
\end{itemize}
\end{definition}

\begin{definition}[Dynamics]
    From global state $s$, the global state after firing transition $tr=A\to b_i$ is denoted $s \cdot tr = (s \setminus \{b_{1-i}\}) \cup \{b_{i}\}, b_{1-i} \in s$.
    The state of a certain automaton $a$ is noted $(s\cdot tr)[a]$.
\end{definition}
To describe the evolution of an ABAN, we use the notion of trajectory:
\begin{definition}[Trajectory]
Given ABAN $AB = (\mathbf{\Sigma},\mathbf{L},\mathbf{T})$ and a global initial state $\alpha\in \mathbf{L}$, a trajectory $t$ from $\alpha$ is a sequence of transitions $t=tr_1::\cdots :: tr_i::\cdots ::tr_n$ with $tr_i\in\mathbf{T}$ and each $tr_i$ is firable in $(\alpha \cdot tr_1 \cdot \ldots \cdot tr_{i-1})$.
From $\alpha$, the global state after firing all transitions of $t$ is denoted $\alpha \cdot t$.
\end{definition}

%From a given initial state $\alpha$, the state after firing $\delta$ is denoted $\alpha\cdot \delta$ and its local form of certain automaton $a$ is noted $(\alpha\cdot \delta)[a]$.
\begin{definition}[Reachability]
Given an global initial state $\alpha$, global state $\Omega$ is reachable iff there exists a trajectory $\delta$ such that $\alpha\cdot \delta=\Omega$, denoted $reach(\alpha, \Omega)$, taking Boolean value $\mathbf{True}$ or $\mathbf{False}$.
Likewise, local state $\omega=a_i$ is reachable iff there exists a trajectory $\delta$ such that $(\alpha\cdot \delta)[a]=a_i$, denoted $reach(\alpha, \omega)$.
\end{definition}
\begin{example}\label{example:aban}
Fig. \ref{fig:1} shows an ABAN with initial state $\alpha=\langle a_0,b_0,c_0,d_0,e_0\rangle$ and a possible trajectory from $\alpha$: $\delta=\acm{d_0}{b_0}{b_1}::\acm{b_1}{d_0}{d_1}::\acm{d_1}{c_0}{c_1}::\acm{b_1,c_1}{a_0}{a_1}$. After firing $\delta$, final state $\Omega=\alpha\cdot \delta=\langle a_1,b_1,c_1,d_1,e_0\rangle$.
$\Omega=\langle a_1,b_1,c_1,d_1,e_0\rangle$ or $\omega=a_1$ is said reachable from $\alpha$ \textit{via} trajectory $\delta$, that is $reach(\alpha,a_1)=\mathbf{True}$ and $reach(\alpha,\Omega)=\mathbf{True}$.
\end{example}
\begin{figure}[ht]
\centering
\input{exampleAN}
\caption{Example of ABAN, where circles stand for Boolean states within an automaton and gray ones are initial states.}\label{fig:1}
\end{figure}	

To simplify the notations, all the initial states of ABAN are set to 0 by default.
\section{Static analysis of reachability property}\label{sect:3}
To approach various dynamical properties of such networks, Local Causality Graph (LCG) is an efficient static analytic tool for reachability put forward by Paulev\'e \textit{et al.} \cite{pauleve2011}. 
LCG determines the existence of trajectory of the desired state without traversing the whole state space.

LCG functions as follows: its over-approximation and under-approximation which give respectively a necessary condition and a sufficient condition of reachability. 
With these conditions, we can conclude in many cases.

More importantly, LCG is also able to provide one with a trajectory if $\omega_i$ is reachable suggested by under-approximation.
We are not going to detail the original version of this trajectory finding technique, instead, we propose its adaptation for ABAN in order to approach the solution of inconclusive cases.
In this paper, only binary networks are studied, so we propose a simplified form of LCG instead of two LCGs (over and under-approximation) which is well suited for the present need.
The drawback is also clear: there are inconclusive cases, which means LCG is neither able to solve in this situation, nor able to generate a trajectory (if reachable).
To improve the conclusiveness of this method, we simplified the LCG for over-approximation for binary situations, called SLCG.

To give LCG a wider applicability, in Appendix \ref{appendix:C}, any BN is transformable to ANs and then SLCG is applicable to its analyses of dynamical properties.
\subsection{Simplified Local Causality Graph (SLCG)}
\begin{definition}[SLCG]\label{defSLCG}
Given an ABAN $AB =(\mathbf{\Sigma},\mathbf{L},\mathbf{T})$, an initial state $\alpha$ and a target state $\omega$, SLCG $l=(V_{\mathrm{state}},V_{\mathrm{solution}},E)$ is the smallest recursive structure with $E \subseteq(V_{\mathrm{state}}\times V_{\mathrm{solution}})\cup(V_{\mathrm{solution}}\times V_{\mathrm{state}})$ which satisfies:
\begin{eqnarray*}
    \omega&\in& V_{\mathrm{state}} \\
    a_i\in V_{\mathrm{state}} &\Leftrightarrow& \{(a_i, sol_{a_i})| a_i\in \alpha\}\subseteq E \\
    sol_{a_i}\in V_{\mathrm{solution}}&\Leftrightarrow& \{(sol_{a_i},\mathbf{V}_a(sol_{a_i})\}\subseteq E
\end{eqnarray*}
where $V_{\mathrm{state}}\subseteq\mathbf{LS}$ is the set of states, $V_{\mathrm{solution}}\subseteq \mathbf{T}$ is the set of solutions and $\mathbf{V}_a$ is the set of required local states of $sol_{a_i}$.
\end{definition}
Intuitively, when the recursive construction is complete, SLCG is in fact a digraph with state nodes $V_{\mathrm{state}}$ and solution nodes $V_{\mathrm{solution}}$. 
$E$ consists of the edges between state nodes and solution nodes. 
To access certain local states, at least one of its successive solution (corresponding transitions from solution nodes) needs to be fired; to make one solution node firable, all of its successive local states need to be satisfied. 
A recursive reasoning of reachability begins with a state node representing desired local state, goes through $a_i\mapsto sol_{a_i}\mapsto b_j \cdots$ and ends with initial state (possibly reachable) or a local state without solution successor (unreachable). 
With SLCG, one can compute the pseudo-reachability of a local state, which is a necessary condition of reachability.

\begin{definition}[Pseudo-reachability]\label{defPseudoReach}
Given an SLCG $l=(V_{\mathrm{state}},V_{\mathrm{solution}},E)$ with initial state $\alpha$, the pseudo-reachability of node $v\in V_{\mathrm{state}}$ is defined as
\begin{equation}
\nonumber
    r'(\alpha,v)=
    \begin{cases}
    \mathrm{\bf True} & {\rm if\ } v\in \alpha\\
    \mathrm{\bf False} & {\rm if\ } v\not\in \alpha\ {\rm and} \not\exists(s,sol) \in E\\
    %\bigvee_{(s,sol) \in E} \mathrm{firable}(sol) & otherwise
    \bigvee_{(s,sol) \in E} (\bigwedge_{(sol,s)\in E} r'(\alpha,s)) & {\rm otherwise}
\end{cases}
\end{equation}
%where $\mathrm{firable}(sol)=\bigwedge_{(sol,s)\in E} r'(\alpha,s)$. 

\end{definition}
\begin{example}
In Fig \ref{fig:2}, the left solution node of $a_1$ is not useful because its successor $e_1$ does not have any successive solution node, \textit{i.e.} $e_1$ is unreachable;
the right solution node of $a_1$ requires $b_1$ and $c_1$, they finally lead to $d_0$ then to $\varnothing$.
\textit{i.e.} nothing is needed to reach $d_0$ as $d_0$ appears in the initial state (trivial solution).
One can figure out state nodes act as OR gates while solution nodes act as AND gates. The pseudo-reachability $r'(\alpha,a_1)$ is computed recursively as follows:
\begin{align*}
r'(\alpha,a_1)&=r'(\alpha,e_1)\lor(r'(\alpha,b_1)\land r'(\alpha,c_1))\\
&=r'(\alpha,b_1)\land r'(\alpha,d_1)=r'(\alpha,b_1)=r'(\alpha,d_0)=\mathbf{True}
\end{align*}
\end{example}

\begin{figure}[ht]
\centering
\input{LCGexampleAN}
\caption{SLCG showing the local causality of $a_1$ of the ABAN in Fig \ref{fig:1}, with the squares representing local states and small circles representing solution nodes}
\label{fig:2}
\end{figure}

The algorithm of SLCG construction is in Appendix \ref{appendix:B}.

\subsection{Limitation of SLCG}\label{limitation}
Although SLCG allows one to reason the pseudo-reachability locally without traversing the whole state space, it is not equivalent to the reachability if there exists the following structures:
\begin{enumerate}
\item Cycles in SLCG
\item Conflicts in SLCG

\end{enumerate}
To be more formal, a cycle (1) is in the form of $a_i\mapsto\cdots\mapsto a_i$, i.e. to access $a_i$, one has to reach first $a_i$. This self-involvement makes the reachability inconclusive. 
A conflict (2) is that a solution node has multiple successors generating branches, and there are different states of the same automaton \textit{i.e.} $a_i$ and $a_{1-i}$. 
We can not decide the order of reaching these states, because reaching one local state may disable the reachability of another one.
Sometimes there exists a trajectory which accesses these states in certain order, sometimes there does not exist such.

In the following examples, if we ignore those limitations, SLCG does not imply real reachability.


\begin{example}\label{example:reach}
In Fig \ref{fig:1} and 
Fig \ref{fig:2}, although there is a conflict, $a_1$ is reachable.
\end{example}

\begin{example}\label{example:unreach}
In Fig. \ref{fig:3}, $\mathbf{\Sigma}=\{a,b,c\}$, $\mathbf{T}=\{\acm{b_0}{a_0}{a_1},\ \acm{a_0}{b_0}{b_1},\ \acm{\{a_1,b_1\}}{c_0}{c_1}\}$,  desired final state $\omega=a_1$. 
Both $a_1$ and $b_1$ are reachable, but they can not be reached simultaneously.
In the SLCG, there are two branches, $a_1\mapsto b_0$ and $b_1\mapsto a_0$.
Automata $a$ and $b$ involve themselves in different branches, reaching one of them disables the reachability of another one.
\end{example}

\begin{figure}[ht]
\centering
\input{LCG_limitation}
\caption{The ABAN and the SLCG of example 2}
\label{fig:3}
\end{figure}
In \textit{Example \ref{example:reach}}, $a_1$ is reachable, while in \textit{Example \ref{example:unreach}}, $c_1$ is unreachable. This inconclusiveness is a limitation of SLCG as $r'(\alpha,\omega)$ is not equivalent to $reach(\alpha,\omega)$.

As there are cycles in SLCG generated by feedback loops in biological regulatory networks, the existing approach does not allow a solution generally.

%Even though we broadened the applicability of SLCG, this method is still not universally applicable for all ABANs or BNs due to the limitations. 
From the former examples, we realize that it is difficult to solve the reachability problem in general. 
In the rest of this paper, we are going to discuss how to improve the performance of existing approaches and our new methods. 

\section{Heuristics for inconclusive cases}\label{sect:4}
SLCG loses its generality of solution due to the existence of AND gates.
In this section, we are trying to make a little compromise in exactitude in order to have a general solution of reachability problem. 
As a consequence, the out-degree of corresponding AND gates in SLCG is bounded to $O(1)$.
This hypothesis is reasonable, because in ordinary biological networks, every component interacts only with a small part of the whole network \cite{akutsu2007control}.
To face with an arbitrary ABAN in this context, for now, the remaining tasks are cycles and conflicts in its SLCG.
\subsection{Preprocessing of SLCG}\label{sectprecond}
\subsubsection{Detection of cycles}
The notion of cycle can be expanded to Strongly Connected Components (SCC) of size greater than 1 as an SCC may contain several nested cycles. 
In \cite{tarjan1972}, the search of SCCs can be done in $O(|V|+|E|)$ time. 
%As SLCG is in fact a sparse graph (the out-degree is limited to $O(1)$), the search of SCCs can be done in $O(|V|)$, \textit{i.e.} linear time.

\subsubsection{Removing cycles}
\begin{theorem}\label{cycletheo}
Given a cycle, if it contains no OR gate% towards outside of cycle
, all the local states in the cycles are unreachable.
\end{theorem}

\begin{proof}
Suppose an arbitrary cycle $C=a_i\mapsto \cdots b_j\mapsto\cdots \mapsto a_i$, with $\mapsto$ an edge in the SLCG.
Note that $r'(\alpha,a_i)\implies r'(\alpha,b_j)\implies r'(\alpha,b_j.\text{next})\implies \cdots\implies r'(\alpha,a_i)$.
According to the definition of $r'$, $r'(\alpha,a)=\mathbf{True}$ only if $\exists c_k\in C$ and $c_k\in \alpha$.
If there exists such $c_k$, $C$ should not exist as the reasoning stops at $c_k$ and does not form a cycle, contradiction.
$r'(\alpha,a_i)=r'(\alpha,b_j)=\cdots =\mathbf{False}$.\qed
\end{proof}

With Theorem \ref{cycletheo}, before stepping into the next part of dealing with AND gates, we can perform a recursive preprocessing by deleting the cycles in SLCG to ensure no cycle remaining.

\subsection{AND Gates in SLCG}\label{sectAndGates}
After preprocessing, we can get rid of cycles.
The next step is to analyze an SLCG with only AND gates.
To achieve this goal, we need to find a trajectory reaching all the components of the given AND gates simultaneously.
These components form a joint state, and if the joint state is reachable, the corresponding transition of AND gate can be fired. 

In Fig \ref{fig:1}, $s=\{ b_1,c_1\}$ is a joint state, when $s$ is reached, transition \ac{b_1,c_1}{a_0}{a_1} is firable.
As the cycles there are no cycles, the order reaching the members in a joint state is the only factor that affects the final reachability. 
The reachability of a joint state can be then formulated as sequential reachability:
\begin{definition}[Sequential reachability]
Let joint state $s=\{ls_1,\ldots,ls_n\}$, $p_1\ldots p_n$ is an arbitrary order of $1\ldots n$ and sequence $seq=ls_{p_1}::\ldots::ls_{p_n}$, sequential reachability of $seq$ is denoted $reach(\alpha,seq)=reach(\alpha,ls_1)::\ldots::reach(\alpha,ls_n)$.
From initial state $\alpha$, $s$ is reachable in the order $seq$ by following the trajectories given by SLCG.
\end{definition}

\begin{example}
Fig \ref{fig:5} shows the SLCG for reachability of $c_1$ in ABAN with transitions $\mathbf{T}=\{\acm{a_1,b_1}{c_0}{c_1},\acm{b_0}{a_0}{a_1},\acm{c_0}{b_0}{b_1}\}$.
\end{example}
\begin{figure}[ht]
\centering
\input{ExampleOrderLCG}
\caption{Reachability depends on firing order}
\label{fig:5}
\end{figure}

$a_1$ and $b_1$ are reachable respectively but is not necessarily for $c_1$.
If we begin with the branch with $a_1$, $s=\{a_1,b_1\}$ is reachable with trajectory $\acm{b_0}{a_0}{a_1}::\acm{c_0}{b_0}{b_1}::\acm{a_1,b_1}{c_0}{c_1}$. 
However if we begin with the branch $b_1$, after firing $\acm{c_0}{b_0}{b_1}$, $b_0$ is no longer reachable, resulting the unreachability of $a_1$.
We have $reach(\alpha,a_1::b_1::c_1)=\mathbf{True}$ and $reach(\alpha,b_1::a_1::c_1)=\mathbf{False}$.

As the firing order matters, we come to verify all the possible sequential reachabilities of certain joint state to obtain its reachability.

\begin{proposition}\label{theoperm}
Given joint state $s=\{ls_1,\ldots,ls_n\}$, with all the local states in $s$ are reachable: $reach(\alpha,ls_i)=\mathbf{True},\ \forall i\in[1,n]$, the set of permutations of $s$ is denoted $Perm(s)=\{(ls_1::ls_2,::\ldots ::ls_n),\ \cdots,\ (ls_n::ls_{n-1}::\ldots,::ls_1)\}$. $\bigvee reach(\alpha,Perm(s))=\mathbf{True}$ is a necessary condition of $reach(\alpha,s)=\mathbf{True}$.
\end{proposition}
\begin{proof}
Notation: $a_i\triangleright b_j$ means that $a_i$ must appear before $b_j$.

Necessity: if there exists a permutation $perm_i\in Perm$ s.t. $reach(\alpha,perm_i)=\mathbf{True}$, then $s$ can be reached according to $perm_i$.
To reach $s$, every local state in SLCG is mandatory to be reached.
Given $\bigvee reach(\alpha,Perm(s))=\mathbf{False}$, does there exist a permutation $perm(Ls)$ s.t. $reach(\alpha,s)=\mathbf{True}$?

For solvable conflicts, $perm(s)$ probably covers one of the admissible order.
One possible counterexample is shown in Fig. \ref{FigConflictInForks}.
\qed\end{proof}

It is remarkable that the former approach is efficient in deciding reachability and finding reaching trajectory, but it has a drawback: if there exists a solvable conflict in different forks, traversing permutations may be not able to find the trajectory towards goal state.
In Fig \ref{FigConflictInForks}, if $sol_{c_1}$ is resolved first, automaton $d$ will be on state $d_1$, which disables the reachability of $b_1$.
In other cases, the trajectory of $a_1$ is retrievable.
\begin{figure}[ht]
\centering
\input{ConflictInForks}
\caption{Conflicts in different forks}\label{FigConflictInForks}
\end{figure}

However there is more than one AND gate in general biological networks and those AND gates could be chained \textit{e.g.} \cite{samaga2009logic}, \textit{i.e.} the successors of certain AND gate contain other AND gates.
We analyze first the simple AND gates $simp$ (without successive AND gates) by traversing its permutations.
If all elements in $simp$ are reachable, update initial state by firing all the transitions and delete the successors of $simp$, then restart the process from finding simple AND gates.
During the whole process, if an AND gate is not reachable after traversing its permutations, the final goal state is not reachable as the SLCG is linked by logical AND. 
Otherwise, when the process terminates, there is no AND gate, SLCG is conclusive as there is no cycle or conflict.

%The statement above is the worst case: in reality, all AND gates are not necessarily composed of exact $I$ components, and permutations are determined to be unreachable before verification as its subsets may have been confirmed unreachable in other tentatives.

For example: given an AND gate $sol_a=b\land c\land d$, where $b,c,d$ are local states.
Normally 6 realizing orders need checking: $b::c::d$, $b::d::c$, $c::b::d$, $c::d::b$, $d::b::c$ and $d::c::b$. 
If we find the order $b::c$ is not realizable when verifying the first realizing order, then we do not have to verify the reachability of $b::c::d$ and $b::d::c$ where $b$ occurs before $c$. $d::b::c$ is not included, because firing $d$ changes its state before firing $b::c$.


\subsection{Heuristic on OR gates}\label{sec:OR}
In the previous section, without OR gates (one state node has multiple solution successors), reachability problem is solvable in polynomial time.
As every \textbf{OR gate} has multiple choices, to avoid combinatorial explosion, we use a simple heuristic: 
choose randomly one assignment for each trial.
Then we can construct a new LCG without \textbf{OR gate}, every state node has exactly one successive solution node.
In fact, if the desired state is reachable, it is probable that exact solution is found during the trial because there are more than one choice that makes the desired state reachable.

\subsection{Overall Process}\label{sectOverall}
Combining all the parts, the whole process of PermReach is shown as follows:
\begin{enumerate}
\item Precondition initial SLCG, cycles are deleted (Section \ref{sectprecond})
\item Build decision trees for AND gates and OR gates
\item Launch the heuristic on OR gates, obtain an SLCG with pure AND gates 
\item Tackle ABAN with AND gates, if reachable, quit; if not, return to step 3 
\end{enumerate}

\section{Implementation and Benchmarks}\label{sect:5}
The overall process in section \ref{sectOverall} is implemented in Python\footnote{Implementation and testing data sets are available at \url{https://github.com/XinweiChai/LCG-in-ASP}}. 
To evaluate the performance in large \textit{in silico} networks, we take T-cell Receptor model (TCR) \cite{saez2007logical} and epidermal growth factor receptor model (EGFR) \cite{samaga2009logic} as examples, with the former one containing 95 components and 206 transitions and the latter one containing 104 components and 389 transitions respectively. 

These models are originally Boolean networks.
According to Appendix \ref{appendix:C}, they are transformable to ABANs. We then take several automata as input, varying exhaustively their initial states combinations ($2^{init\_state}$), take the reachability of the states of another automata set as output.
We first test the performance of traditional model checkers, Mole\footnote{\url{http://www.lsv.fr/~schwoon/tools/mole}} and NuSMV\footnote{\url{http://nusmv.fbk.eu}}, in which Mole turns out to be timeout for 6 in 12 outputs, and all timeout for NuSMV in model EGFR.
Due to the big state space, traditional model checkers are not effective. 

To validate our approach, we first use a small model: phage-$\lambda$ model \cite{thieffry1995dynamical} to compare with an alternative reachability analyzer Pint \cite{pauleve2012}. In this model with 4 components and 12 transitions (without taking consideration of the self-regulations), our result shows complete conclusiveness while Pint is not able to figure out the reachability of $[cll=1]$. 
In big examples TCR and EGFR,
%Folschette \textit{et al.} using Pint \cite{folschette2015},
although PermReach takes more time than Pint, it outputs the sequence from initial state towards final state.
More importantly, it gives conclusive reachability for any input. 
In the TCR tests, PermReach gives exactly the same result as Pint did. As for EGFR tests, PermReach takes the inconclusive cases of Pint as input, and returns conclusive outputs.

%in his paper, there are about Almost all the examples in this paper are ``inconclusive'' in Pint, but they are solvable \textit{via} the presented heuristic technique. In \cite{folschette2015}, Folschette \textit{et al.} ran tests over the possible variations of 13 input nodes (different initial states), and observed the reachability of other 12 components. In total $12\times 2^{13}=98,304$ instances are tested. Among these tests, there are 9,986 (10,16\%) inconclusive instances. We conducted tests on these instances and found out they are conclusive in our methods.

\begin{table}[ht]
\centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
  	Model	&\multicolumn{2}{c|}{$\lambda$-phage}	&	  \multicolumn{2}{c|}{TCR} & \multicolumn{2}{c|}{EGFR}  \\
    \hline
    Inputs&\multicolumn{2}{c|}{4}	&	  \multicolumn{2}{c|}{3} & \multicolumn{2}{c|}{13}\\
    \hline
    Outputs&\multicolumn{2}{c|}{4} &	  \multicolumn{2}{c|}{5} & \multicolumn{2}{c|}{12} \\
    \hline
    Total tests&\multicolumn{2}{c|}{$2^4\times 4=64$} & \multicolumn{2}{c|}{$2^3\times 5=40$} & \multicolumn{2}{c|}{$2^{13}\times 12=98,304$}\\
    \hline
    Analyzer  &  Pint       &\textbf{PermReach}    &  Pint       &\textbf{PermReach}   &  Pint       &\textbf{PermReach}             \\
    \hline
    Reachable    & 36(56\%)& 38(59\%)   &  \multicolumn{2}{c|}{16(40\%)}  & 64,282(65.4\%)&74,268(75.5\%)\\
    \hline
    \textbf{Inconclusive} & \textcolor{red}{\textbf{2(3\%)}}&\textcolor{blue}{\textbf{0(0\%)}}& \multicolumn{2}{c|}{0(0\%)}    &\textcolor{red}{\textbf{9,986(10.1\%)}}&\textcolor{blue}{\textbf{0(0\%)}}  \\
    \hline
    Unreachable     &  \multicolumn{2}{c|}{26(41\%)} &  \multicolumn{2}{c|}{24(60\%)} &24,036(24.5\%)&24,036(24.5\%)\\
    \hline
    Total runtime &  $<1$s       &  $<1$s &  \textbf{7s}       &  \textbf{0.85s}        & \textbf{9h50min}              & \textbf{15min31s}      \\
    \hline
    \end{tabular}
\caption{Results of the tests on large-scale examples using Intel Core i7-3770 CPU, \@3.4GHz, 8.00G RAM. 
Column “Pint” gives the related results on ANs, while column “PermReach” gives the results for ABANs. 
“True”, “Inconclusive” and “False” give respectively the number of different results of reachability, while “Max time” and “Total time” depict respectively the maximum time of the individual computations.}
\label{tab:2}
\end{table}

We carried some random tests\footnote{Random ABANs are generated as follows: given the number of transitions, for every transition, the head of the }, with the number of automata varying from $10,20,\ldots,100,200,\ldots,1000$.
We varied also the density of the transitions (transitions per automaton on average) from 1 to 10.
Results of small examples are validated by traditional model checker as it always gives exact result.

As seen in the previous results, our heuristic technique is more conclusive than the reasoning of Pint. 
In the configuration of the heuristic approach, if there are less than 20 OR gates after preprocessing in Section \ref{sectprecond}, the computation will be shifted from heuristic to global search as the size of enumeration is acceptable.
There are only 11 OR gates in EGFR model, therefore the results are firmly conclusive. 


To sum up, PermReach has a better time performance than traditional exhaustive model checkers (Mole and NuSMV); on the other hand, it is more conclusive than abstract analyzers (Pint) while keeping a reasonable time performance.

\section{Conclusion and future work}\label{sect:6}
This paper proposes an expressive formalism ABAN to study the reachability problem. 
The original approach SLCG has limited conclusiveness because static and local reasoning does not simulate all real system dynamics. 
Due to the complexity of global search, developing a heuristic technique based on joint states becomes a feasible choice.
The heuristic method reproduces the system dynamics by traversing possible orders of transitions. 
This ``dynamic tentative'' makes it closer to real dynamics than LCG is.

Future work: in the reasoning of AND gates, the computation on permutations is expensive but is still not conclusive enough, see Fig \ref{FigConflictInForks}. 
To speed up the whole procedure and improve the conclusiveness, we plan to apply SAT (Satisfiability) solvers or Answer Set Programming (ASP) to refine the analysis of transition orders ($\triangleright$) in the same fork and those across forks. 
In addition, we may contemplate the extension of our heuristic technique to multivalued models.


\bibliographystyle{splncs04}
\bibliography{bib}   % name your BibTeX data base

\appendix
\section{Algorithm}\label{appendix:B}
The construction of an SLCG is realized by iterative updates:
\begin{algorithm}[ht]
\begin{algorithmic}
\State Initialization: 
$Ls\gets \{\omega\}$, $\mathbf{LS}\gets\{\omega\}$, $\mathbf{Sol}\gets \varnothing$
\While{$Ls\neq \varnothing$}
	\For{$a_i\in Ls$}
		\State $Ls\gets Ls\backslash a_i$
		\If{$a_i\in init\_state$}
			\State $a_i{\rm .next}=sol_{a_i}$
            \State $sol_{a_i}{\rm .next}=\varnothing$
    	\Else
    		\For{$sol=\acm{A}{a_{1- i}}{a_i}\in \mathbf{T}$}
    			\State $a_i{\rm .next}\gets a_i{\rm .next}\cup sol$
    			\For{$b_j\in A$}
    				\State $sol{\rm .next}\gets b_j$
    			\EndFor
    			\State $Ls\gets Ls\cup b_j$
                \State $\mathbf{LS}\gets \mathbf{LS}\cup Ls$
    		\EndFor
    		\State$\mathbf{Sol}\gets \mathbf{Sol}\cup a_i{\rm .next}$           
    	\EndIf
	\EndFor
\EndWhile
\State\Return{$(\mathbf{LS},\mathbf{Sol})$}
\end{algorithmic}
\caption{SLCG construction}
\label{algorithm:2}
\end{algorithm}
\section{Transformation from general BNs to ABANs}\label{appendix:C}

Given Boolean functions $v_i(t+1)=f_i(\mathbf{V}_i)$, with $\mathbf{V}_i$ the set of participating variables among $v_1(t),\cdots,v_n(t)$.
Boolean operators are transformable to the composition of $\lnot,\land,\lor$ (\textit{e.g.} $a\ \mathbf{XOR} \ b = (a\land \lnot b)\lor (\lnot a\land b)$), and Boolean functions possess an equivalent CNF (clausal normal form) thanks to its distributivity.
As ANs interpret transitions in the way of disjunctions of conjunctions, all BNs are transformable to ANs. 
We can see that it does not matter whether the dynamics is synchronous or asynchronous, because these transformations are only exerted on functions/transitions.

Example: 

Let $G_B=(V,F)$ a BN with $V=\{a,b,c,d,e\}$, and has only one Boolean function, $F=\{f(a)= (b\lor c)\land(d\lor e)\}$, we have 
$f(a)=(b\land d)\lor(b\land e)\lor(c\land d)\lor(c\land e)$, and $\lnot f(a)=(\lnot b\land \lnot c)\lor(\lnot d\land \lnot e)$. 
The equivalent ABAN is then constructed: 5 automata $\mathbf{\Sigma}=\{a,b,c,d,e\}$, with transitions: $\mathbf{T}=\{\acm{b_1,d_1}{a_0}{a_1},\ \acm{b_1,e_1}{a_0}{a_1},\ \acm{c_1,d_1}{a_0}{a_1},\ \acm{c_1,e_1}{a_0}{a_1},\ \acm{b_0,c_0}{a_1}{a_0},\ \acm{d_0,e_0}{a_1}{a_0}\}$.
\end{document}