% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\RequirePackage{amsmath}
\documentclass[runningheads]{llncs}
%
\usepackage{amssymb}
\usepackage[noend]{algpseudocode} 
\usepackage{algorithm}
\usepackage{subfigure}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{graphicx}
\newcommand{\acm}[3]{\{#1\}\rightarrow#3}
\newcommand{\ac}[3]{$\{#1\}\rightarrow#3$}
\newcommand{\omesi}{^\omega_\varsigma}
\usepackage{url}
\input{macros}
\input{macros-ph}
\input{macros-abstr}
\input{tikzstyles2}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{A Heuristic for Reachability Problem in Asynchronous Binary Automata Networks\thanks{Supported by Laboratoire des Sciences du Num\'erique de Nantes and China Scholarship Council}}
%
\titlerunning{A Heuristic for Reachability Problem}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Xinwei Chai \and Morgan Magnin \and Olivier Roux}
%
\authorrunning{X. Chai et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Laboratoire des Sciences du Num\'erique de Nantes, UMR CNRS 6004 \'Ecole Centrale de Nantes, 1 rue de la No\"e - B.P. 92101 - 44321 Nantes Cedex 3, France \\
\email{\{xinwei.chai, morgan.magnin, olivier.roux\}@ls2n.fr}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
On the demand of efficient reachability analysis due to the inevitable complexity of large-scale biological models, this paper is dedicated to a novel approach: PermReach, for reachability problem of our new framework, Asynchronous Binary Automata Networks (ABAN). 
ABAN is an expressive modeling framework which contains all the dynamics behaviors performed by Asynchronous Boolean Networks. 
Compared to Boolean Networks (BN), ABAN has a finer description of state transitions (from a local state to another, instead of symmetric Boolean functions). 
To analyze the reachability properties on large-scale models (like the ones from systems biology), previous works have exhibited an efficient abstraction technique called Local Causality Graph (LCG).
However, this technique may be not conclusive. Our contribution here is to extend these results by tackling those complex intractable cases \textit{via} a heuristic technique. 
To validate our method, tests were conducted in large biological networks and randomly generated examples, showing that our method is more conclusive and faster than existing ones.

\keywords{Asynchronous Binary Automata Networks \and Simplified Local Causality Graph \and Heuristics.}
\end{abstract}
\section{Introduction}
\label{intro}
Works on concurrent systems have been of interest for systems biology for a decade \cite{bockmayr2002using,bortolussi2008modeling,wiley2003computational}. 
In this context, the challenges nowadays consist of not only model validation with regard to existing knowledge on systems but also behavior prediction of these systems. 
%In this context, reachability issue on formal models is a critical challenge which not only validates models with regard to existing knowledge on systems, but also addresses predictions of the behavior of these systems.
With quantities of available data provided by new technologies, \textit{e.g.} DNA microarray \cite{marx2013}, there is a growing need for high-performance analytic tools, especially for reachability problem, as many static and dynamical properties are transformable to the reachability of certain states.
Reachability problem has been studied under many different modeling frameworks for decades \cite{akutsu2007control,barrett2006complexity,Daws1998,esparza1998,mayr1984,wozna2003} and takes an important part in Model Checking \cite{clarke20142}. 
State Space Explosion problem arises in reachability analysis of concurrent systems as the state space is exponential to the number of variables in the model, thus disables naive approaches. 

Related studies have been carried over various frameworks: Plateau et al. \cite{plateau1991stochastic} propose a Stochastic Automata Network and study its steady-state behavior, while the reachability analysis is absent; Li et al. \cite{li2012reachability,li2014stability} investigate theoretically the stability, controllability and reachability of Switched Boolean Networks, but their method remains computationally expensive.  
To tackle the State Space Explosion problem, symbolic model checking \cite{burch1992symbolic} and SAT-solvers based on ordered binary decision diagrams (OBDDs) and SAT-solvers (satisfiability) \cite{abdulla2000symbolic} have been considered over years, but the solution space of original problem remains huge.
Paulev\'e \textit{et al.} \cite{folschette2015,pauleve2011} have proposed Automata Network (AN) for modeling concurrent systems. 
They provide an approach to address this issue by designing a static abstraction (with an over-approximation and an under-approximation of the real dynamics) inspired by abstract interpretation: Local Causality Graph (LCG). 
This static analysis drastically reduces the state-space and avoids costly global search \cite{pauleve2012}.
With the initiative of LCG, this paper is devoted to the study of general reachability problems in Asynchronous Binary Automata Networks (ABAN), then to gain a more profound understanding of the dynamics of biological systems. 
Many biological networks are encoded in Boolean style \cite{kauffman1969,akutsu2007control}, because BN is a simple formalism but with strong expressiveness also due to the imprecision of raw data.
However BN may be not expressive enough.
To model the dynamic behavior ``$a\gets$ $1$ when $b=1$'', one has $a(t+1)=b(t)$ in BN.
$a$ always follows the evolution of $b$ but with an unwanted behavior ``$a\gets 0$ when $b=0$''.
ABAN models this dynamics as \textit{via} \ac{b_1}{a_0}{a_1} without redundancy. 
Besides, BNs are transformable to Automata Networks, and this property makes ABAN more extendable (Appendix \ref{appendix:C}).

In many circumstances, LCG is able to give a conclusive result on the reachability of target states in polynomial time to the number of automata \cite{pauleve2016goal}. 
However there exists inconclusive cases which disable the reasoning of sufficient conditions.
After diving into the mechanics of LCG and the inconclusive cases, we figure out why those cases are intractable by pure static analysis. 
We develop a heuristic technique aiming at the application for general instances. 
This heuristic method has a better performance on conclusiveness than static reasoning, because it attempts to explore a part of the system dynamics \textit{via} partial verification.
In the end, we conduct tests on signaling networks of around 100 components (TCR and EGFR, see Section \ref{sect:5}): the results of LCG contain inconclusive instances \cite{folschette2015} while our new method solves them.

This paper is organized as follows: in section 2, we will introduce the formal background, Asynchronous Binary Automata Network (ABAN); section 3 presents the analysis of dynamics using only static reasoning; 
section 4 is the core content of this paper, concerning the heuristics for reachability problems; 
the benchmarks are in section 5 and the conclusion is in section 6.
\section{Preliminaries}\label{sect:2}
\textit{Notations}:

$::$ sequential connector;
$a.next$ the successor of $a$; $a.pred$ the predecessor of $a$

Asynchronous Binary Automata Network (ABAN) is a variant of traditional AN.
Binary means that every automaton has exactly two possible states $(0,1)$ and asynchronous implies the update scheme with no more than one automaton can change its value at a time. 

\begin{definition}[ABAN]
An ABAN is a triplet $AB = (\mathbf{\Sigma},\mathbf{L},\mathbf{T})$, where:
\begin{itemize}
\item $\mathbf{\Sigma}\triangleq\{a,b,\ldots\}$ is the finite set of automata with every component possessing a Boolean state;
\item $L_a\triangleq\{a_0,a_1\}$ is the set of Boolean states of automaton $a\in \mathbf{\Sigma}$, $\mathbf{LS}\triangleq \underset{a\in \mathbf{\Sigma}}{\cup} L_a$ is the set of all local states,  $\mathbf{L}\triangleq \underset{a\in \mathbf{\Sigma'}}{\times} L_a$ is the set of joint states where $\mathbf{\Sigma'}\subseteq\mathbf{\Sigma}$. Particularly, if $\mathbf{\Sigma'}=\mathbf{\Sigma}$, $\mathbf{L}$ is the set of global states. 
The state of automaton $a$ at state $s$ is denoted $s[a]=a_i$;
\item $\mathbf{T}\subseteq \{A\to b_{i}\mid b\in \mathbf{\Sigma} \land A\in \mathbf{L}\}$ is the set of transitions, where $A$ is the set of required states (condition) for the transition, which allows to flip $b_{1-i}$ to $b_i$. 
For transition $tr=A\to b_{i}$, $A$ is called the body, noted $b(tr)$ and $b_i$ is called the head, noted $h(tr)$.
\end{itemize}
\end{definition}

\begin{definition}[Dynamics]
    From global state $s$, the global state after firing transition $tr=A\to b_i$ is denoted $s \cdot tr = (s \setminus \{b_{1-i}\}) \cup \{b_{i}\}, b_{1-i} \in s$.
    The state of a certain automaton $a$ is noted $(s\cdot tr)[a]$.
\end{definition}
To describe the evolution of an ABAN, we use the notion of trajectory:
\begin{definition}[Trajectory]
Given ABAN $AB = (\mathbf{\Sigma},\mathbf{L},\mathbf{T})$ and a global initial state $\alpha\in \mathbf{L}$, a trajectory $t$ from $\alpha$ is a sequence of transitions $t=tr_1::\cdots :: tr_i::\cdots ::tr_n$ with $tr_i\in\mathbf{T}$ and each $tr_i$ is firable in $(\alpha \cdot tr_1 \cdot \ldots \cdot tr_{i-1})$.
From $\alpha$, the global state after firing all transitions of $t$ is denoted $\alpha \cdot t$.
\end{definition}

%From a given initial state $\alpha$, the state after firing $t$ is denoted $\alpha\cdot t$ and its local form of certain automaton $a$ is noted $(\alpha\cdot t)[a]$.
\begin{definition}[Reachability]
Given a global initial state $\alpha$, global state $\Omega$ is reachable iff there exists a trajectory $t$ such that $\alpha\cdot t=\Omega$, denoted $reach(\alpha, \Omega)$, taking Boolean value $\mathbf{True}$ or $\mathbf{False}$.
Likewise, local state $\omega=a_i$ is reachable iff there exists a trajectory $t$ such that $(\alpha\cdot t)[a]=a_i$, denoted $reach(\alpha, \omega)$.
\end{definition}
\begin{example}\label{example:aban}
Fig. \ref{fig:1} shows an ABAN with initial state $\alpha=\langle a_0,b_0,c_0,d_0,e_0\rangle$ and a possible trajectory from $\alpha$: $t=\acm{d_0}{b_0}{b_1}::\acm{b_1}{d_0}{d_1}::\acm{d_1}{c_0}{c_1}::\acm{b_1,c_1}{a_0}{a_1}$. After firing $t$, final state $\Omega=\alpha\cdot t=\langle a_1,b_1,c_1,d_1,e_0\rangle$.
$\Omega=\langle a_1,b_1,c_1,d_1,e_0\rangle$ or $\omega=a_1$ is said reachable from $\alpha$ \textit{via} trajectory $t$, that is $reach(\alpha,a_1)=\mathbf{True}$ and $reach(\alpha,\Omega)=\mathbf{True}$.
\end{example}
\begin{figure}[ht]
\centering
\input{exampleAN}
\caption{An example of ABAN, where circles stand for Boolean states within an automaton and gray ones are initial states.}\label{fig:1}
\end{figure}	

\section{Static analysis of reachability property}\label{sect:3}
To approach various dynamical properties of such networks, Local Causality Graph (LCG) is an efficient static analytic tool for reachability put forward by Paulev\'e \textit{et al.} \cite{pauleve2011}. 
LCG determines the existence of trajectory of the target state without traversing the whole state space.

LCG functions as follows: its over-approximates and under-approximates the real reachability, giving respectively a necessary condition and a sufficient condition of reachability. 
With these conditions, we can conclude in many cases.
But there exists inconclusive cases, which is our main topic.
In this paper, only binary situations are studied.
Instead of studying two LCGs (over and under-approximation), we propose a simplified form, called simplified LCG (SLCG) which is well suited for the present need.
We try to analyze the reachability problem by doing more than static analysis to have a better conclusiveness.

Moreover, to give LCG a wider applicability, Appendix \ref{appendix:C} shows BNs are transformable to ABANs and then SLCG is also applicable for BNs.

\subsection{Simplified Local Causality Graph (SLCG)}
\begin{definition}[SLCG]\label{defSLCG}
Given an ABAN $AB =(\mathbf{\Sigma},\mathbf{L},\mathbf{T})$, an initial state $\alpha$ and a target state $\omega$, SLCG $l=(V_{\mathrm{state}},V_{\mathrm{solution}},E)$ is the smallest recursive structure with $E \subseteq(V_{\mathrm{state}}\times V_{\mathrm{solution}})\cup(V_{\mathrm{solution}}\times V_{\mathrm{state}})$ which satisfies:
\begin{eqnarray*}
    \omega&\in& V_{\mathrm{state}} \\
    a_i\in V_{\mathrm{state}} &\Leftrightarrow& \{(a_i, sol_{a_i})| a_i\in \alpha\}\subseteq E \\
    sol_{a_i}\in V_{\mathrm{solution}}&\Leftrightarrow& \{(sol_{a_i},\mathbf{V}_a(sol_{a_i})\}\subseteq E
\end{eqnarray*}
where $V_{\mathrm{state}}\subseteq\mathbf{LS}$ is the set of states, $V_{\mathrm{solution}}\subseteq \mathbf{T}$ is the set of solutions and $\mathbf{V}_a$ is the set of required local states of $sol_{a_i}$.
\end{definition}
Intuitively, when the recursive construction is complete, SLCG is in fact a digraph with state nodes $V_{\mathrm{state}}$ and solution nodes $V_{\mathrm{solution}}$. 
$E$ consists of the edges between state nodes and solution nodes. 
To access certain local states, at least one of its successive solution (corresponding transitions from solution nodes) needs to be fired; to make one solution node firable, all of its successive local states need to be satisfied. 
A recursive reasoning of reachability begins with a state node representing target local state, goes through $a_i\to sol_{a_i}\to b_j \cdots$ and ends with initial state (possibly reachable) or a local state without solution successor (unreachable). 
With SLCG, one can compute the pseudo-reachability of a local state, which is a necessary condition of reachability.

\begin{definition}[Pseudo-reachability]\label{defPseudoReach}
Given an SLCG $l=(V_{\mathrm{state}},V_{\mathrm{solution}},E)$ with initial state $\alpha$, the pseudo-reachability of node $v\in V_{\mathrm{state}}$ is defined as
\begin{equation}
\nonumber
    r'(\alpha,v)=
    \begin{cases}
    \mathrm{\bf True} & {\rm if\ } v\in \alpha\\
    \mathrm{\bf False} & {\rm if\ } v\not\in \alpha\ {\rm and} \not\exists(s,sol) \in E\\
    %\bigvee_{(s,sol) \in E} \mathrm{firable}(sol) & otherwise
    \bigvee_{(s,sol) \in E} (\bigwedge_{(sol,s)\in E} r'(\alpha,s)) & {\rm otherwise}
\end{cases}
\end{equation}
%where $\mathrm{firable}(sol)=\bigwedge_{(sol,s)\in E} r'(\alpha,s)$. 

\end{definition}
\begin{example}
In Fig. \ref{fig:2}, the left solution node of $a_1$ is not useful because its successor $e_1$ does not have any successive solution node, \textit{i.e.} $e_1$ is unreachable;
the right solution node of $a_1$ requires $b_1$ and $c_1$, they finally lead to $d_0$ then to $\varnothing$.
\textit{i.e.} nothing is needed to reach $d_0$ as $d_0$ appears in the initial state (trivial solution).
One can figure out state nodes act as \textbf{OR gates} while solution nodes act as \textbf{AND gates}. The pseudo-reachability $r'(\alpha,a_1)$ is computed recursively as follows:
\begin{align*}
r'(\alpha,a_1)&=r'(\alpha,e_1)\lor(r'(\alpha,b_1)\land r'(\alpha,c_1))\\
&=r'(\alpha,b_1)\land r'(\alpha,d_1)=r'(\alpha,b_1)=r'(\alpha,d_0)=\mathbf{True}
\end{align*}
\end{example}

\begin{figure}[ht]
\centering
\input{LCGexampleAN}
\caption{This SLCG shows the local causality of $a_1$ of the ABAN in Fig. \ref{fig:1}, with the squares representing local states and small circles representing solution nodes}
\label{fig:2}
\end{figure}

The algorithm of SLCG construction is in Appendix \ref{appendix:B}.

\subsection{Limitation of SLCG}\label{limitation}
Although SLCG allows one to reason the pseudo-reachability locally without traversing the whole state space, it is not equivalent to the reachability if there exists the following structures:
\begin{enumerate}
\item Cycles in SLCG
\item Firing order constraints in SLCG

\end{enumerate}
To be more formal, a cycle (1) is in the form of $a_i\to\cdots\to a_i$, i.e. to access $a_i$, one has to reach first $a_i$. This self-involvement makes the reachability inconclusive. 
A constraint (2) is that a solution node has multiple successors generating branches, and there are different states of the same automaton \textit{i.e.} $a_i$ and $a_{1-i}$. 
We can not decide the order of reaching these states, because reaching one local state may disable the reachability of another one.
Sometimes there exists a trajectory which accesses these states in certain order, sometimes there does not exist such.

In the following examples, if we ignore those limitations, SLCG does not imply real reachability.


\begin{example}\label{example:reach}
In Fig. \ref{fig:1} and 
Fig. \ref{fig:2}, although there is a constraint, $a_1$ is reachable.
\end{example}

\begin{example}\label{example:unreach}
In Fig. \ref{fig:3}, $\mathbf{\Sigma}=\{a,b,c\}$, $\mathbf{T}=\{\acm{b_0}{a_0}{a_1},\ \acm{a_0}{b_0}{b_1},\ \acm{\{a_1,b_1\}}{c_0}{c_1}\}$, the target state $\omega=a_1$. 
Both $a_1$ and $b_1$ are reachable, but they can not be reached simultaneously.
In the SLCG, there are two branches, $a_1\to b_0$ and $b_1\to a_0$.
Automata $a$ and $b$ involve themselves in different branches, reaching one of them disables the reachability of another one.
\end{example}

\begin{figure}[ht]
\centering
\input{LCG_limitation}
\caption{The ABAN and the SLCG of \textit{Example \ref{example:unreach}}, $\alpha=\langle a_0,b_0,c_0\rangle$}
\label{fig:3}
\end{figure}
In \textit{Example \ref{example:reach}}, $a_1$ is reachable, while in \textit{Example \ref{example:unreach}}, $c_1$ is unreachable. This inconclusiveness shows the limitation of SLCG as $r'(\alpha,\omega)$ is not equivalent to $reach(\alpha,\omega)$.
Also, as there are usually cycles in SLCG generated by feedback loops in biological regulatory networks, the existing approach does not lead to a general solution.
%Even though we broadened the applicability of SLCG, this method is still not universally applicable for all ABANs or BNs due to the limitations. 
In the rest of this paper, we are going to discuss how to improve the performance of existing approaches and our new methods. 

\section{Heuristics for general cases}\label{sect:4}
SLCG loses its generality of solution due to the existence of \textbf{AND gates} and cycles.
In this section, we are trying to first delete the cycles in the SLCGs without changing the reachability, then perform heuristics to deal with the \textbf{AND gates} as well as \textbf{OR gates} which may contain firing order constraints in the topology.
Thus we can obtain a more general solution than pure static analysis (pseudo-reachability) of the reachability problem.
As a consequence, the out-degree of corresponding \textbf{AND gates} in SLCG should be bounded to $O(1)$.
This hypothesis is reasonable, because in ordinary biological networks, every component interacts only with a small part of the whole network \cite{akutsu2007control}.

\subsection{Overall Process}\label{sectOverall}
Our algorithm PermReach first constructs the SLCG and filter it with pseudo-reachability. 
If pseudo-reachability does not return \textbf{False}, we then try to remove the cycles using Theorem \ref{th:break_cycle}.
If this does not work for all cycles, we launch the random choice at each \textbf{OR gate} to remove them.
In an SLCG without \textbf{OR gate}, we apply Theorem \ref{th:break_cycle2} to get rid of the cycles.
We obtain an SLCG with \textbf{AND gates}, which can be solved using exhaustive search in permutations.
If this search fails to find an admissible trajectory, we restart the random choice at \textbf{OR gates}.
These processes loop at most $k$ times.
The value of $k$ is discussed in the benchmarks.

\begin{itemize}
    \item Input: an ABAN $AB$, a global initial state $\alpha$, a target local state $\omega$ and a max number of iterations $k$
    \item Output: reachability $reach(\alpha, \omega)$
\end{itemize}
\begin{enumerate}
\item Construct the SLCG
\item Compute the pseudo-reachability, if $r'(\alpha,\omega)=\mathbf{False}$, return $\mathbf{False}$
\item Detect the cycles in the SLCG and try to remove them 
\item Loop at most $k$ times:
\begin{enumerate}
    \item Launch the heuristic to remove \textbf{OR gates} 
    \item If there remains cycles:
    \begin{enumerate}
        \item Back to step (a)
    \end{enumerate}
    \item Tackle the SLCG with only \textbf{AND gates}, if we find a trajectory from $\alpha$ to $\omega$, return \textbf{True}; if not, back to step (a)
\end{enumerate}
\item Return \textbf{Inconclusive} (probably unreachable)
\end{enumerate}

In the following sections, we introduce the details of each step.

\subsection{Preprocessing of SLCG}\label{sectprecond}
After constructing the SLCG and filtering by pseudo-reachability, we need to deal with some structures weakening conclusiveness: cycles and \textbf{OR gates}.
\subsubsection{Detection of cycles}
The notion of cycle can be expanded to Strongly Connected Components (SCC) of size greater than 1 as an SCC may contain several nested cycles. 
In \cite{tarjan1972}, the search of SCCs can be done in $O(|V|+|E|)$ time. 
%As SLCG is in fact a sparse graph (the out-degree is limited to $O(1)$), the search of SCCs can be done in $O(|V|)$, \textit{i.e.} linear time.

\subsubsection{Removing cycles}
\begin{theorem}\label{th:break_cycle}
Given a cycle $x\to \circ \to \cdots \to \circ \to x$ in an SLCG, if there is at most one incoming edge to the cycle, the cycle can be removed.
\end{theorem}
\begin{proof}
If there is no incoming edge, the target state $x$ must be in the cycle. 
The edge $x.pred\to\circ\to x$ can be removed, because the reachability of $x.pred$ requires $x$, but $x$ is the target state, which is never reached before the other local states in the SLCG are reached.
Thus the transition corresponding to this edge is never fired and the edge can be removed.
Similarly, if there is an outside incoming edge $a\to \circ \to x$, $x.pred\to\circ\to x$ is also removable.
\qed
\end{proof}


\begin{example}
    \begin{figure}[H]
        \centering
        \input{cycle2}
        \caption{SLCG containing cycle $x\to \circ \to y \to \circ \to z\to \circ \to x$}
        \label{cycle1}
    \end{figure}
    
    In Fig. \ref{cycle1}, the pseudo-reachability of $a$ is 
    $$r'(l,a)=r'(l,x)=r'(l,y)=r'(l,z)=r'(l,x)\lor r'(l,w)$$
    To reach $x$, we need to reach $z$, but $z$ cannot depend on $x$ as $x$ is already to be reached. 
    Self-dependence appears: $x$ is reachable if $x$ is reachable.
    Thus edge $z\to \circ \to x$ is deleted (dashed line).
\end{example}

\begin{theorem}\label{th:break_cycle2}
Given a cycle, if it contains no \textbf{OR gate}% towards outside of cycle
, all the local states in the cycles are unreachable.
\end{theorem}

\begin{proof}
Suppose an arbitrary cycle $C=a_i\to \cdots b_j\to\cdots \to a_i$, with $\to$ an edge in the SLCG.
Note that $r'(\alpha,a_i)\implies r'(\alpha,b_j)\implies r'(\alpha,b_j.next)\implies \cdots\implies r'(\alpha,a_i)$.
According to the definition of $r'$, $r'(\alpha,a)=\mathbf{True}$ only if $\exists c_k\in C$ and $c_k\in \alpha$.
If there exists such $c_k$, $C$ should not exist as the reasoning stops at $c_k$ and does not form a cycle, contradiction.
$r'(\alpha,a_i)=r'(\alpha,b_j)=\cdots =\mathbf{False}$.\qed
\end{proof}

\subsubsection{Heuristic on OR gates}\label{sec:OR}
Every state node is an \textbf{OR gate}, we have to choose one of its successive solution nodes to access the state. 
A set of \textbf{OR gate} choices is called an \textit{assignment}.
As every \textbf{OR gate} has multiple choices, traversing all the possibilities may lead to combinatorial explosion.
We use a simple heuristic: 
choose randomly one assignment for each trial.

Then we can construct a new LCG without \textbf{OR gate}, every state node has exactly one successive solution node.
In fact, if the target state is reachable, it is probable that exact solution is found during the trials because there are more than one path connecting $\alpha$ and $\omega$.

With Theorem \ref{th:break_cycle} and Theorem \ref{th:break_cycle2}, we can stepping into the next part dealing with \textbf{AND gates} without obstacles.

\subsection{AND Gates in SLCG}\label{sectAndGates}
After preprocessing, we can get rid of cycles and \textbf{OR gates}.
The next step is to analyze an SLCG with only \textbf{AND gates}.
We need to find a trajectory reaching all the components of the given \textbf{AND gates} simultaneously.
These components form a joint state, and if the joint state is reachable, the corresponding transition of \textbf{AND gate} can be fired. 

In Fig. \ref{fig:1}, $s=\{ b_1,c_1\}$ is a joint state, when $s$ is reached, transition \ac{b_1,c_1}{a_0}{a_1} is firable.
As the cycles there are no cycles, the order reaching the members in a joint state is the only factor that affects the final reachability. 
The reachability of a joint state can be then formulated as sequential reachability:
\begin{definition}[Sequential reachability]
Let joint state $s=\{ls_1,\ldots,ls_n\}$, $p_1,\ldots ,p_n$ be an arbitrary order of $1,\ldots ,n$ and sequence $seq=ls_{p_1}::\ldots::ls_{p_n}$.
The sequential reachability of $seq$ is denoted $reach(\alpha,seq)=reach(\alpha,ls_1)::\ldots::reach(\alpha,ls_n)$.
From initial state $\alpha$, $reach(\alpha,seq)=\mathbf{True}$ if $s$ is reached in the order $seq$ by following the trajectories given by SLCG.
\end{definition}

\begin{example}
Fig. \ref{fig:5} shows the SLCG for reachability of $c_1$ in ABAN with transitions $\mathbf{T}=\{\acm{a_1,b_1}{c_0}{c_1},\acm{b_0}{a_0}{a_1},\acm{c_0}{b_0}{b_1}\}$.
$a_1$ and $b_1$ are reachable respectively but is not necessarily for $c_1$.
If we begin with the branch with $a_1$, $s=\{a_1,b_1\}$ is reachable with trajectory $\acm{b_0}{a_0}{a_1}::\acm{c_0}{b_0}{b_1}::\acm{a_1,b_1}{c_0}{c_1}$. 
However if we begin with the branch $b_1$, after firing $\acm{c_0}{b_0}{b_1}$, $b_0$ is no longer reachable, resulting the unreachability of $a_1$.
We have $reach(\alpha,a_1::b_1::c_1)=\mathbf{True}$ and $reach(\alpha,b_1::a_1::c_1)=\mathbf{False}$.
\end{example}
\begin{figure}[ht]
\centering
\input{ExampleOrderLCG}
\caption{The ABAN and the SLCG of \textit{Example 5}, $\alpha=\langle a_0,b_0,c_0\rangle$. 
The reachability depends on firing order of transitions}
\label{fig:5}
\end{figure}



As the firing order matters, we come to verify all the possible sequential reachabilities of certain joint state to obtain its reachability.

\begin{proposition}\label{theoperm}
Given joint state $s=\{ls_1,\ldots,ls_n\}$, with all the local states in $s$ are reachable: $reach(\alpha,ls_i)=\mathbf{True},\ \forall i\in[1,n]$, the set of permutations of $s$ is denoted $Perm(s)=\{(ls_1::ls_2,::\ldots ::ls_n),\ \cdots,\ (ls_n::ls_{n-1}::\ldots,::ls_1)\}$. $\bigvee_{i\in Perm(s)} reach(\alpha,i)=\mathbf{True}$ is a sufficient condition of $reach(\alpha,s)=\mathbf{True}$.
\end{proposition}
\begin{proof}
If $\exists perm_i\in Perm(s)$ s.t. $reach(\alpha,perm_i)=\mathbf{True}$, $s$ can be reached according to the order in $perm_i$.
To reach $s$, every local state in SLCG is mandatory to be reached, as according to the definition of SLCG, it is the smallest structure which contains all the needed local states and transitions for the target state. As long as there is no \textbf{OR gates}, all the transitions in the SLCG must be fired to reach the target state.
For solvable constraints, $Perm(s)$ can cover some of the admissible orders.
One possible counterexample is shown in Fig. \ref{FigConflictInForks}.
\qed\end{proof}

In case where there is more than one \textbf{AND gate} and these \textbf{AND gates} could be chained, \textit{e.g.} \cite{samaga2009logic}.
The successors of certain \textbf{AND gate} contain other \textbf{AND gates}.
We analyze first the simple \textbf{AND gates} $simp$, i.e. the successors of $simp$ does not contain any \textbf{AND gates}.
If all local states within $simp$ are reachable via the search of permutations, we can update the initial state by firing all the transitions and also update the SLCG by deleting the successors of $simp$. 
Then we restart this process from new simple \textbf{AND gates} until we reach finally the target state.

However PermReach is not complete. 
If there exists constraints in different branches, traversing all the permutations may be not sufficient to find the admissible trajectory towards target state.
In Fig. \ref{FigConflictInForks}, among the simple \textbf{AND gates}, if $sol_{c_1}$ is solved first, automaton $d$ will be at the state $d_1$, which disables the reachability of $b_1$.
In other cases, the trajectory of $a_1$ may not be retrievable by PermReach.
\begin{figure}[ht]
\centering
\input{ConflictInForks}
\caption{Counterexample of PermReach, this SLCG is for studying $reach(\alpha,a_1)$}\label{FigConflictInForks}
\end{figure}
%The statement above is the worst case: in reality, all \textbf{AND gates} are not necessarily composed of exact $I$ components, and permutations are determined to be unreachable before verification as its subsets may have been confirmed unreachable in other tentatives.

%For example: given an \textbf{AND gate} $sol_a=b\land c\land d$, where $b,c,d$ are local states.
%Normally 6 realizing orders need checking: $b::c::d$, $b::d::c$, $c::b::d$, $c::d::b$, $d::b::c$ and $d::c::b$. 
%If we find the order $b::c$ is not realizable when verifying the first realizing order, then we do not have to verify the reachability of $b::c::d$ and $b::d::c$ where $b$ occurs before $c$. $d::b::c$ is not included, because firing $d$ changes its state before firing $b::c$.

\section{Implementation and benchmarks}\label{sect:5}
The overall process in section \ref{sectOverall} is implemented in Python\footnote{Implementation and testing data sets are available at \url{https://github.com/XinweiChai/LCG-in-ASP}}. 
To validate our approach in large \textit{in silico} networks, we take T-cell Receptor model (TCR) \cite{saez2007logical} and epidermal growth factor receptor model (EGFR) \cite{samaga2009logic} as examples, with the former one containing 95 components and 206 transitions and the latter one containing 104 components and 389 transitions respectively. 

These models are originally Boolean networks.
According to Appendix \ref{appendix:C}, they are transformable to ABANs. We then take several automata as input, varying exhaustively their initial states combinations ($2^{init\_state}$), take the reachability of the states of another automata set as output.
We first test the performance of traditional model checkers, Mole\footnote{\url{http://www.lsv.fr/~schwoon/tools/mole}} and NuSMV\footnote{\url{http://nusmv.fbk.eu}}, in which Mole turns out to be timeout for 6 in 12 outputs, and all timeout for NuSMV in model EGFR.
Due to the big state space, traditional model checkers are not effective. 

To validate our approach, we first use a small model: phage-$\lambda$ model \cite{thieffry1995dynamical} to compare with an alternative static reachability analyzer Pint \cite{pauleve2012}. In this model with 4 components and 12 transitions, our result shows full conclusiveness while Pint returns the reachability of $[cll=1]$ with inconclusive.
Big networks TCR and EGFR are already tested by Folschette \textit{et al.} modeling in Automata Network with priority \cite{folschette2015}. 
In the TCR tests, PermReach gives exactly the same result as \cite{folschette2015} did as there is no inconclusive cases. As for EGFR tests, PermReach shows also full conclusiveness while Automata Network with priority does not.
%in his paper, there are about Almost all the examples in this paper are ``inconclusive'' in Pint, but they are solvable \textit{via} the presented heuristic technique. In \cite{folschette2015}, Folschette \textit{et al.} ran tests over the possible variations of 13 input nodes (different initial states), and observed the reachability of other 12 components. In total $12\times 2^{13}=98,304$ instances are tested. Among these tests, there are 9,986 (10,16\%) inconclusive instances. We conducted tests on these instances and found out they are conclusive in our methods.

\begin{table}[ht]
\centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
  	Model	&\multicolumn{2}{c|}{$\lambda$-phage}	&	  \multicolumn{2}{c|}{TCR} & \multicolumn{2}{c|}{EGFR}  \\
    \hline
    Inputs&\multicolumn{2}{c|}{4}	&	  \multicolumn{2}{c|}{3} & \multicolumn{2}{c|}{13}\\
    \hline
    Outputs&\multicolumn{2}{c|}{4} &	  \multicolumn{2}{c|}{5} & \multicolumn{2}{c|}{12} \\
    \hline
    Total tests&\multicolumn{2}{c|}{$2^4\times 4=64$} & \multicolumn{2}{c|}{$2^3\times 5=40$} & \multicolumn{2}{c|}{$2^{13}\times 12=98,304$}\\
    \hline
    Analyzer  &  Pint       &\textbf{PermReach}    &  Pint       &\textbf{PermReach}   &  Pint       &\textbf{PermReach}             \\
    \hline
    Reachable    & 36(56\%)& 38(59\%)   &  \multicolumn{2}{c|}{16(40\%)}  & 64,282(65.4\%)&74,268(75.5\%)\\
    \hline
    \textbf{Inconclusive} & \textcolor{red}{\textbf{2(3\%)}}&\textcolor{blue}{\textbf{0(0\%)}}& \multicolumn{2}{c|}{0(0\%)}    &\textcolor{red}{\textbf{9,986(10.1\%)}}&\textcolor{blue}{\textbf{0(0\%)}}  \\
    \hline
    Unreachable     &  \multicolumn{2}{c|}{26(41\%)} &  \multicolumn{2}{c|}{24(60\%)} &24,036(24.5\%)&24,036(24.5\%)\\
    \hline
    Total runtime &  $<1$s       &  $<1$s &  \textbf{7s}       &  \textbf{0.85s}        & \textbf{9h50min}              & \textbf{15min31s}      \\
    \hline
    \end{tabular}
\caption{Results of the tests on large-scale examples using Intel Core i7-3770 CPU, \@3.4GHz, 8.00G RAM. 
Column “Pint” gives the related results on ANs, while column “PermReach” gives the results for ABANs. 
“True”, “Inconclusive” and “False” give respectively the number of different results of reachability, while “Max time” and “Total time” depict respectively the maximum time of the individual computations.}
\label{tab:2}
\end{table}

Besides the tests done by others, we also carry tests on some randomly generated ABANs to check the generality and the time-performance of PermReach. 
Given the number of transitions, for every transition $tr$, the head $a_h$ is randomly chosen from $\mathbf{LS}$, the first element of the body $A_1$ is chosen from $\mathbf{LS}_1=\mathbf{LS}\setminus \{a_h,a_{1-h}\}$.
For $i>1$, if $A_{i-1}=b_x$ exists, we generate $A_i$ with an 80\% probability, choosing from $\mathbf{LS}_i=\mathbf{LS}_{i-1}\setminus \{b_x,b_{1-x}\}$. 
 
One test is on the different numbers of automata with the same density (transitions per automaton on average) of ABAN. Fixing the density to 3, we vary the number of automata  from $10,20,\ldots,100,200,\ldots,1000$.
In the cases with less than 300 automata, the runtime of each reachability check is less than 0.1s.
Fig. \ref{fig:sizeTest} shows the average runtime is less than 5 seconds even if there are 1000 automata. 
Moreover, the longest runtime among the test sets is less than 20s. 
Because we stop the computation if one reachability check takes more than 20s and we note it as timeout.
We find no timeout case.

\begin{figure}[ht]
    \subfigure[0.5\textwidth][Runtime w.r.t. ABAN size]{
        \centering
    \input{curveSizeTest.tex}
    \label{fig:sizeTest}
    }
    ~
    \subfigure[0.5\textwidth][Runtime w.r.t. ABAN density]{
        \centering
    \input{curveInconc.tex}
    \label{fig:inconcTest}
    }
    \caption{Runtime of PermReach on random ABANs}
\end{figure}

Another test is on the different density with the same number of automata. 
Fixing the number of automata to 20, we vary the density of the transitions from 1 to 12.
We find the runtime peak is at density 7, a possible explanation is that even the topology of the network is more complex with the growth of the density, more transitions lead to more paths from the initial state to the target state, thus PermReach succeed with less trials.
Among the reachability results, the ABANs of high density have more \textbf{True}s than those of low density.
Last but not least, in the implementation, we set arbitrarily iteration limit $k=100\times|\mathbf{OR\  gates}|+1$. 
Apart from handmade counterexample in Fig. \ref{FigConflictInForks}, there is no case in the tests where the iterations reach $k$ times.
%In the configuration of the heuristic approach, if there are less than 20 \textbf{OR gates} after preprocessing in Section \ref{sectprecond}, the computation will be shifted from heuristic to global search as the size of enumeration is acceptable.
%There are only 11 \textbf{OR gates} in EGFR model, therefore the results are firmly conclusive. 


To sum up, PermReach has a better time performance than traditional model checkers based on global search (Mole and NuSMV); furthermore, it is more conclusive and has a better time performance than abstract analyzer (Pint).

\section{Conclusion and future work}\label{sect:6}
This paper proposes an expressive formalism ABAN to study the reachability problem. 
Due to the complexity of global search and inconclusiveness of pure static search, developing a heuristic technique based on static analysis becomes a feasible choice.
The heuristic method PermReach reproduces the system dynamics by searching admissible orders of transitions.
The benchmarks display its conclusiveness and efficiency.

Future work: the computation of permutations could be heavy in the networks bigger than the tests in this paper and is still not fully conclusive. 
To speed up the whole procedure and improve the conclusiveness, we plan to apply SAT (Satisfiability) solvers or Answer Set Programming (ASP) to refine the analysis of transition orders. 
In addition, we may consider the extension of PermReach to multivalued models.


\bibliographystyle{splncs04}
\bibliography{bib}   % name your BibTeX data base

\appendix
\section{Algorithm}\label{appendix:B}
The construction of an SLCG is realized by iterative updates:
\begin{algorithm}[ht]
\begin{algorithmic}
\State Initialization: 
$Ls\gets \{\omega\}$, $\mathbf{LS}\gets\{\omega\}$, $\mathbf{Sol}\gets \varnothing$
\While{$Ls\neq \varnothing$}
	\For{$a_i\in Ls$}
		\State $Ls\gets Ls\backslash a_i$
		\If{$a_i\in init\_state$}
			\State $a_i.next=sol_{a_i}$
            \State $sol_{a_i}.next=\varnothing$
    	\Else
    		\For{$sol=\acm{A}{a_{1- i}}{a_i}\in \mathbf{T}$}
    			\State $a_i.next\gets a_i.next\cup sol$
    			\For{$b_j\in A$}
    				\State $sol.next\gets b_j$
    			\EndFor
    			\State $Ls\gets Ls\cup b_j$
                \State $\mathbf{LS}\gets \mathbf{LS}\cup Ls$
    		\EndFor
    		\State$\mathbf{Sol}\gets \mathbf{Sol}\cup a_i.next$           
    	\EndIf
	\EndFor
\EndWhile
\State\Return{$(\mathbf{LS},\mathbf{Sol})$}
\end{algorithmic}
\caption{SLCG construction}
\label{algorithm:2}
\end{algorithm}
\section{Transformation from general BNs to ABANs}\label{appendix:C}

Given Boolean functions $v_i(t+1)=f_i(\mathbf{V}_i)$, with $\mathbf{V}_i$ the set of participating variables among $v_1(t),\cdots,v_n(t)$.
Boolean functions could be transformed to equivalent CNF (conjunctive normal form) and DNF (disjunctive normal form) if the length of Boolean functions is limited to $O(1)$ \cite{miltersen2005converting} which is often the case.
\begin{proposition}[Transformation from BN to ABAN]
Given a BN $G_B=(V,F)$, with its functions in CNF form $v^i(t+1)=A_1\land\ldots A_j \ldots\land A_n$ and DNF form $v^i(t+1)=A'_1\lor\ldots A_k\ldots\lor A'_m$, an equivalent ABAN $AB$ has transitions $A_j\to v^i_1$ and $\lnot A_k\to v^i_0$ where $A_j$ are disjunctions and $A'_K$ are conjunctions.
\end{proposition}
\begin{example}
Let $G_B=(V,F)$ a BN with $V=\{a,b,c,d,e\}$, and has only one Boolean function, $F=\{f(a)= (b\lor c)\land(d\lor e)\}$, we have 
$f(a)=(b\land d)\lor(b\land e)\lor(c\land d)\lor(c\land e)$, and $\lnot f(a)=(\lnot b\land \lnot c)\lor(\lnot d\land \lnot e)$. 
The equivalent ABAN is then constructed: 5 automata $\mathbf{\Sigma}=\{a,b,c,d,e\}$, with transitions: $\mathbf{T}=\{\acm{b_1,d_1}{a_0}{a_1},\ \acm{b_1,e_1}{a_0}{a_1},\ \acm{c_1,d_1}{a_0}{a_1},\ \acm{c_1,e_1}{a_0}{a_1},\ \acm{b_0,c_0}{a_1}{a_0},\ \acm{d_0,e_0}{a_1}{a_0}\}$.
\end{example}
\end{document}